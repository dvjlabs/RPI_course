{"config":{"lang":["it"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Raspberry Pi","text":"<p>Un semplice corso per parlare di:</p> <ul> <li> <p>Raspberry Pi: un computer delle dimensioni di una carta di credito</p> </li> <li> <p>Internet of Things: la moda elettronica del momento. Del presente... e del futuro!!!</p> </li> <li> <p>Thonny: il nostro editor Python preferito!!! Python c'entra sempre...</p> </li> <li> <p>OpenCV: Una libreria utile per l'elaborazione al computer delle immagini e dei video in tempo reale.</p> </li> </ul> <p>Poi... per il divertimento di tutti, allestiremo anche una sezione di tutorials, per (provare a) fare cose in autonomia!!</p> <p>Cominciamo!</p> <p>Raspberry Pi Sensori e RPi OpenCV</p> <p> </p>"},{"location":"iot/00_intro/","title":"Introduzione","text":"<p>Giusto due parole per introdurre:</p> <ul> <li>blah blah</li> </ul> <p>Iniziamo!!</p>"},{"location":"iot/00_intro/#_1","title":"...","text":"<p>Blah blah</p> <p> </p>"},{"location":"iot/01_wiringpi/","title":"WiringPi","text":"<p>WiringPi (http://wiringpi.com/) \u00e8 una libreria di interfacciamento con il GPIO del Raspberry. Viene rilasciata tramite la licenza GNU LGPLv3 e supporta un consistente numero di linguaggi di programmazione, in maniera nativa (C, C++, RTB) o tramite wrappers (Python e altri...). E' stata progettata in analogia al \"Wiring System\" di Arduino, da cui il nome WiringPi per collegare il concetto di Wiring System con il Raspberry Pi.</p> <p>La libreria WiringPi include una utility a riga di comando denominata gpio che pu\u00f2 essere utilizzata per visualizzare e modificare le impostazioni dei pin GPIO.</p> <p>La libreria WiringPi e la sua estensione in Python saranno lo strumento principale con cui interagiremo con il GPIO, da cui la necessit\u00e0 di capire prima di cosa si tratta e installarla sul nostro Raspberry.</p> <p>Per installarla basta eseguire il semplice comando:</p> <pre><code>$ sudo apt install wiringpi\n</code></pre> <p>confermare con Yes tutte le richieste di APT e al termine testare la buona riuscita dell'operazione.</p> <p>Suggerimento</p> <p>Prima di installare la libreria WiringPi con il comando precedente (e prima di installare qualunque pacchetto con APT), sarebbe saggio aggiornare il database dei pacchetti (update) e poi i pacchetti veri e propri del sistema (upgrade) in modo che tutto sia sincronizzato al meglio.</p> <p>I comandi da eseguire sono:</p> <pre><code>$ sudo apt update\n$ sudo apt upgrade\n</code></pre> <p>Per verificare che effettivamente sia andato tutto bene basta eseguire il comando</p> <pre><code>$ gpio -v\n</code></pre> <p>che dovrebbe fornire una serie di informazioni su di esso.</p> <p>Provare per credere!!!</p>"},{"location":"iot/02_gpio/","title":"GPIO","text":"<p>Qualsiasi esperienza che si vuole effettuare collegando un raspberry ad uno o pi\u00f9 sensori non pu\u00f2 prescindere dalla conoscenza dell'interfaccia hardware predefinita per l'input/output: il General Purpose Input Output, GPIO.</p> <p>Tanto per essere sicuri che ci capiamo, quello fatto come in figura...</p> <p></p> <p>Prendete anche un RPI in mano e guardate bene per capire: il GPIO non \u00e8 altro che la sequenza di PIN, di cui molti funzionano sia per l'input delle informazioni che per l'output delle stesse, a cui \u00e8 possibile collegare praticamente ogni sorta di sensore, analogico o digitale, adatto pi\u00f9 o meno a qualunque scopo. Da tutto questo ragionamento si spiega anche la scelta del nome: General Purpose Input Output.</p> <p>Per gestire questi pin, bisogna prima riconoscerli... e qui nascono le prime difficolt\u00e0! Infatti, a seconda dell'interfaccia utilizzata per gestirli abbiamo 3 diversi modi per numerarli:</p> <ol> <li>GPIO numbering</li> <li>Physical numbering</li> <li>WiringPi numbering</li> </ol>"},{"location":"iot/02_gpio/#gpio-numbering","title":"GPIO numbering","text":"<p>Questo sistema di numerazione dei pin \u00e8 stato stabilito dal produttore dell'interfaccia hardware, ovvero dei pin stessi e del chipset che li controlla. Per chi \u00e8 interessato alla cosa, il controller \u00e8 un Broadcom BCM2835/BCM2836/BCM2837 :)</p> <p>Inutile spiegare tanto a parole quando si pu\u00f2 semplicemente guardare un'immagine e dire vabb\u00e8...</p> <p></p>"},{"location":"iot/02_gpio/#physical-numbering","title":"Physical numbering","text":"<p>Un altro modo di contare i pin \u00e8 quello di numerarli a due a due a partire da in alto a sinistra (il numero 1 \u00e8 il pin pi\u00f9 vicino allo slot della scheda MicroSD)</p> <p>Anche qui, con un'immagine \u00e8 pi\u00f9 semplice:</p> <p></p>"},{"location":"iot/02_gpio/#wiringpi-numbering","title":"WiringPi numbering","text":"<p>Ultimo metodo per \"contare\" i pin \u00e8 quello basato sulla libreria WiringPi. L'immagine che segue \u00e8 presa dal sito WiringPi e confronta i tre metodi di numerazione dei pin</p> <p></p> <p>Un metodo ulteriore per controllare i numeri dei pin del raspberry \u00e8 quello di interrogare direttamente il gpio tramite un piccolo applicativo contenuto nelle librerie WiringPi.</p> <pre><code>$ gpio readall\n</code></pre> <p>L'output di questo comando dovrebbe essere una cosa del genere:</p> <p></p> <p>Leggendo attentamente lo schema riportato possiamo desumere tutte le informazioni necessarie :)</p>"},{"location":"iot/03_breadboard/","title":"La Breadboard","text":"<p>Blah blah (arriva dalla dispensa dell'Esp32)</p>"},{"location":"opencv/00_intro/","title":"Due parole su OpenCV","text":"<p>OpenCV (acronimo di <code>OPEN source Computer Vision</code> Library) \u00e8 una libreria software multipiattaforma nell'ambito della visione artificiale in tempo reale.</p> <p>\u00c8 una libreria software inizialmente sviluppata da Intel, rilasciata con licenza libera e quindi, vista l'utilit\u00e0 e la qualit\u00e0 del codice della stessa, supportata poi da numerose aziende, come dalla comunit\u00e0 opensource.</p> <p>Le funzionalit\u00e0 di base della libreria sono sviluppate in C++, ma essa fornisce interfacce per il supporto dei linguaggi C++, C, Python, Java.</p>"},{"location":"opencv/00_intro/#strumenti-necessari","title":"Strumenti necessari","text":"<p>Serve un dispositivo con un Sistema Operativo che supporti pienamente Python e l'hardware necessario: una CPU in grado di supportare le funzionalit\u00e0 di base di OpenCV e una foto/video camera. Se nell'hardware fosse anche supportata una tastiera... sarebbe tutto pi\u00f9 facile!</p> <p>Il nostro Raspberry presenta tutte le caratteristiche richieste! Lo stesso vale anche (banalmente) per un portatile con videocamera.</p> <p>Visto che parliamo di un Raspberry, il sistema operativo di riferimento sar\u00e0 Linux. Con le dovute cautele, proveremo a costruire esempi validi anche su Windows e/o Mac OS. Il problema riguarda soprattutto l'installazione dei moduli necessari.</p> <p>Proviamo!!</p> <p> </p>"},{"location":"opencv/01_OpenCV/","title":"OpenCV","text":""},{"location":"opencv/01_OpenCV/#ambiente-di-lavoro","title":"Ambiente di lavoro","text":"<p>Vogliamo creare un ambiente virtuale, in modo da ottenere tre risultati importanti:</p> <ol> <li> <p>Provare a 'standardizzare' il lavoro da fare per tutti i Sistemi Operativi</p> </li> <li> <p>Partire da una installazione locale di Python 'pulita', ovvero senza alcun modulo installato (nell'ambiente virtuale)</p> </li> <li> <p>un altro motivo</p> </li> </ol> <p>Creiamo una cartella su cui faremo tutte le nostre prove e i nostri esperimenti ed entriamo con il terminale su di essa.</p> <pre><code>$ pwd\n/home/adjam\n$ mkdir ProveOpenCV\n$ cd ProveOpenCV\n</code></pre> <p>Adesso creiamo un ambiente virtuale e attiviamolo!</p> <pre><code>$ python -m venv venv\n$ source venv/bin/activate.sh\n</code></pre> <p>Suggerimento</p> <p>La creazione (e attivazione) di un ambiente virtuale si pu\u00f2 fare anche direttamente dall'interfaccia di Thonny: dal men\u00f9 ESEGUI , scheda INTERPRETE , in basso a dx, seleziona NUOVO AMBIENTE VIRTUALE e crealo nella cartella <code>venv</code>.</p> <p>Al termine della creazione dell'ambiente virtuale, aprite il terminale tramite Thonny: dal men\u00f9 STRUMENTI, selezionate APRI SHELL DI SISTEMA...</p> <p>Per verificare che l'ambiente \u00e8 effettivamente <code>pulito</code>, digitiamo:</p> <pre><code>$ pip list\nPackage Version\n------- -------\npip     24.3.1\n</code></pre> <p>Dovrebbe essere elencato solo pip o pochissimo altro.</p>"},{"location":"opencv/01_OpenCV/#installazione-opencv","title":"Installazione OpenCV","text":"<p>Dal terminale ove si \u00e8 attivato l'ambiente virtuale (o da quello aperto con Thonny), digitiamo:</p> <pre><code>$ pip install numpy\n$ pip install pillow\n$ pip install opencv-python\n</code></pre> <p>Installiamo prima la libreria <code>numpy</code> perch\u00e9 \u00e8 una diretta dipendenza di OpenCV e perch\u00e9 potrebbe dare problemi nell'installazione. Controlliamo bene che sia andato tutto liscio!</p> <p>Nota</p> <p>La libreria <code>pillow</code> \u00e8 la libreria standard de-facto per la gestione delle immagini in Python. Pillow \u00e8 un gioco di parole fra cuscino (che si mette fra la testa e il letto) e LOW PIL, ovvero Low Python Image Library, nel senso che tutte le librerie Python usano questa per la gestione delle immagini.</p> <p>Per verificare che tutto \u00e8 ok, proviamo il nostro primo test!</p> File: test0.py<pre><code># Controllo versioni Python e OpenCV\nimport sys\nprint(\"Versione Python\", sys.version)\n\nimport cv2\nprint (\"versione OpenCv\", cv2.__version__)\n</code></pre>"},{"location":"opencv/01_OpenCV/#gestione-immagini-con-opencv","title":"Gestione immagini con OpenCV","text":"<p>Proviamo dunque a gestire una immagine con OpenCV! Scaricate una immagine qualunque (per me, il file <code>pippo.jpg</code>) ed eseguite questo codice:</p> File: testImage1.py<pre><code># Mostrare una immagine con OpenCV\nimport cv2\n\nimage = cv2.imread('pippo.jpg')\nprint(\"Dimensione:\", image.shape)\ncv2.imshow(\"Il nostro amico Pippo!\", image)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n</code></pre> <p>Volendo, \u00e8 possibile mostrare una immagine in scala di grigi:</p> File: testImage2.py<pre><code># Mostrare una immagine (in scala di grigi) con OpenCV\nimport cv2\n\nimage = cv2.imread('pippo.jpg', cv2.IMREAD_GRAYSCALE)\ncv2.imshow(\"Il nostro amico Pippo!\", image)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n</code></pre> <p>Chiaramente il focus principale della libreria \u00e8 l'elaborazione video in tempo reale. Per fare questo, \u00e8 necessario gestire la videocamera con Python!</p>"},{"location":"opencv/01_OpenCV/#videocamera","title":"Videocamera","text":"<p>La videocamera dovrebbe essere supportata nativamente da OpenCV, nel senso che se hai una videocamera installata, questi dovrebbe essere in grado di riconoscerla e utilizzarla!</p> <p>Ecco un esempio banale per verificarlo subito!!!</p> Cattura video con OpenCV<pre><code>import cv2\n\nvideoCapture = cv2.VideoCapture(0)\n\nwhile True:\n    # legge 1 frame dalla videocamera...\n    ret, frame = videoCapture.read()\n    # e lo visualizzo!\n    cv2.imshow('Camera',frame)\n\n    # se premi Q, \u00e8 tutto finito!\n    if cv2.waitKey(1) == ord('q'):\n        break\n\n# release the camera from video capture\nvideoCapture.release()\n# De-allocate any associated memory usage\ncv2.destroyAllWindows()\n</code></pre> <p>Se funziona tutto... benissimo!!! Puoi andare avanti Al prossimo capitolo!!! Se invece la videocamera non viene riconosciuta, ad esempio la picamera sul Raspberry, occorre provare qualcosa di diverso!</p> <p>Per quanto riguarda il Raspberry Pi purtroppo siamo in un momento un p\u00f2 imbarazzante: il vecchio software non funziona pi\u00f9 bene, per mancanza di compatibilit\u00e0 con gli aggiornamenti del resto del sistema, mentre il nuovo non ha ancora raggiunto un livello soddisfacente di stabilit\u00e0 e funzionalit\u00e0!</p> <p>In ogni caso, siamo costretti ad affidarci alla nuova versione del software di gestione della camera! Il vecchio non funziona...</p> <p>Per installare tutto su un Raspberry Pi, digitate sul terminale:</p> <pre><code>$ sudo apt install python3-picamera2\n$ sudo apt install rpicam-apps\n</code></pre> <p>La nuova soluzione \u00e8 molto moderna: utilizza la nuovissima libreria <code>libcamera</code>, che sar\u00e0 la libreria di supporto alle videocamere di default su Android, Linux, Raspberry Pi. Purtroppo non \u00e8 ancora... 100% pronta!!! Speriamo bene...</p> <p>Documentazione relativa:</p> <ul> <li>rpicam-apps</li> <li>picamera2 python library</li> </ul> <p>Nella documentazione trovate tutti gli esempi visti sotto relativi a picamera2!</p> <p>Attenzione!</p> <p>Non installate <code>picamera2</code> tramite <code>pip</code>, ma fate esattamente come spiegato sopra tramite <code>apt</code>!</p> <p>Vero che su pip potreste trovare una versione pi\u00e0 nuova del software, ma forse non completamente compatibile con la versione di libcamera che trovate installata sul Raspberry!</p>"},{"location":"opencv/01_OpenCV/#esempi-con-opencv-e-videocamera","title":"Esempi con OpenCV e videocamera","text":"<p>Negli esempi che seguono andremo a testare alcune interessanti funzionalit\u00e0 della libreria OpenCV.</p> <p>Per potenziare le sue gi\u00e0 eccellenti capacit\u00e0, la libreria fornisce dei classificatori, denominati <code>haar-cascades</code> che sono utilizzati per implementare funzionalit\u00e0 specifiche (ad esempio, il rilevamento dei volti, degli occhi, del sorriso, etc...)</p> <p>Solitamente le informazioni necessarie per le funzionalit\u00e0 sono fornite in formato XML. Tutti i file haar-cascades sono disponibili per il download qui: https://github.com/opencv/opencv/tree/master/data/haarcascades</p> <p>In ogni esempio viene indicato chiaramente quali sono i file necessari: vanno scaricati e collocati nella cartella del file Python.</p> <p>Nel primo esempio una prova abbastanza banale: la registrazione di un video tramite le funzionalit\u00e0 di OpenCV!</p> Registrazione Video<pre><code>import cv2\n\nvideoCapture = cv2.VideoCapture(0)\nframe_width = int(cam.get(cv2.CAP_PROP_FRAME_WIDTH))\nframe_height = int(cam.get(cv2.CAP_PROP_FRAME_HEIGHT))\nfourcc = cv2.VideoWriter_fourcc(*'mp4v')\noutputVideoFile = cv2.VideoWriter('output.mp4', fourcc, 20.0, (frame_width, frame_height))\n\nwhile True:\n    ret, frame = videoCapture.read()\n    outputVideoFile.write(frame)\n    cv2.imshow('Camera', frame)\n\n    # Press 'q' to exit the loop\n    if cv2.waitKey(1) == ord('q'):\n        break\n\nvideoCapture.release()\noutputVideoFile.release()\ncv2.destroyAllWindows()\n</code></pre> <p>Esempio di SMILE DETECTION: un rettangolo rosso appare intorno ad ogni bocca che sorride!</p> Smile Detection<pre><code>import cv2\n\n# file necessari (da scaricare e posizionare nella cartella del programma)\nface_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')\neye_cascade = cv2.CascadeClassifier('haarcascade_eye.xml')\nsmile_cascade = cv2.CascadeClassifier('haarcascade_smile.xml')\n\n\ndef detect(gray, frame):\n    faces = face_cascade.detectMultiScale(gray, 1.3, 5)\n    for (x, y, w, h) in faces:\n        cv2.rectangle(frame, (x, y), ((x + w), (y + h)), (255, 0, 0), 2)\n        roi_gray = gray[y:y + h, x:x + w]\n        roi_color = frame[y:y + h, x:x + w]\n        smiles = smile_cascade.detectMultiScale(roi_gray, 1.8, 20)\n\n        for (sx, sy, sw, sh) in smiles:\n            cv2.rectangle(roi_color, (sx, sy), ((sx + sw), (sy + sh)), (0, 0, 255), 2)\n    return frame\n\n\nvideoCapture = cv2.VideoCapture(0)\nwhile videoCapture.isOpened():\n    ret, frame = videoCapture.read()\n    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n    canvas = detect(gray, frame)\n    cv2.imshow('Video', canvas)\n\n    if cv2.waitKey(1) == ord('q'):\n        break\n\nvideoCapture.release()\ncv2.destroyAllWindows()\n</code></pre> <p>La FACE-DETECTION \u00e8 l'operazione di OpenCV che la rende in grado di rilevare un viso e distinguerlo da un pallone, da un piatto, da un quadro, etc...</p> Face Detection<pre><code>import cv2\nimport sys\n\nfaceCascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')\n\nvideoCapture = cv2.VideoCapture(0)\n\nwhile True:\n    ret, frame = videoCapture.read()\n    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n    faces = faceCascade.detectMultiScale(\n        gray,\n        scaleFactor=1.1,\n        minNeighbors=5,\n        minSize=(30, 30),\n    )\n\n    # Draw a rectangle around the faces\n    for (x, y, w, h) in faces:\n        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2)\n    cv2.imshow('Video', frame)\n\n    if cv2.waitKey(1) == ord('q'):\n        break\n\nvideoCapture.release()\ncv2.destroyAllWindows()\n</code></pre> <p>Altra potenzialit\u00e0 di OpenCV: la possibilit\u00e0 di riconoscere gli occhi di una persona e individuarli all'interno di un viso!</p> Riconoscimento degli occhi<pre><code>import numpy as np\nimport cv2\n\nface_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')\neye_cascade = cv2.CascadeClassifier('haarcascade_eye.xml')\n\nvideoCapture = cv2.VideoCapture(0)\n\nwhile True:\n    ret, img = videoCapture.read()\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    faces = face_cascade.detectMultiScale(gray, 1.3, 5)\n\n    for (x,y,w,h) in faces:\n        cv2.rectangle(img,(x,y),(x+w,y+h),(255,255,255),1)\n        roi_gray = gray[y:y+h, x:x+w]\n        roi_color = img[y:y+h, x:x+w]\n\n        eyes = eye_cascade.detectMultiScale(roi_gray)\n        for (ex,ey,ew,eh) in eyes:\n            cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(0,255,0),1)\n\n    cv2.imshow('img',img)\n    if cv2.waitKey(1) == ord('q'):\n        break\n\nvideoCapture.release()\ncv2.destroyAllWindows()\n</code></pre> <p>Ponete un oggetto di colore verde davanti alla vostra webcam e vediamo cosa succede. Una pallina sarebbe l'oggetto perfetto.</p> Riconoscimento Colori<pre><code>import cv2\nimport numpy as np\nimport math\n\nvideoCapture = cv2.VideoCapture(0)\n\nwhile videoCapture.isOpened():\n    ret, frame = videoCapture.read()\n    frame1 = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    frame2 = cv2.GaussianBlur(frame1,(5,5),0)\n    chiaro = np.array([50,80,80])\n    scuro = np.array([80,200,200])\n    frame3 = cv2.inRange(frame2, chiaro,scuro)\n    ret2,frame4 = cv2.threshold(frame3,127,255,0)\n    moments = cv2.moments(frame4)\n    area = moments['m00']\n\n    radius =int( (math.sqrt((area/3.14)))/10)\n    centroid_x, centroid_y = None, None\n\n    if area != 0:\n        c_x = int(moments['m10']/area)\n        c_y = int(moments['m01']/area)\n        print(\"x: \", c_x,\"y: \",c_y)\n\n    # se trovato, nelle sue coordinate disegno cerchio e griglia!\n    if c_x != None and c_y != None:\n        cv2.circle(frame, (c_x,c_y), radius, (0,0,255),2)\n\n    cv2.line(frame,(320,0),(320,480),[255,0,0],1)\n    cv2.line(frame,(0,240),(640,240),[255,0,0],1)\n    cv2.rectangle(frame,(310,230),(330,250),[0,0,255],1)\n    cv2.imshow('Frame',frame)\n\n    if cv2.waitKey(1) == ord('q'):\n        break\n\nvideoCapture.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"opencv/01_OpenCV/#face-recognition","title":"Face Recognition","text":"<p>Il riconoscimento del viso \u00e8 una operazione successiva al semplice rilevamento: questa funzionalit\u00e0 rende i nostri computer (ma anche telefoni, tablet, portatili, etc...) dotati di videocamera di riconoscere la persona che hanno dinnanzi, non semplicemente di individuarne il viso, uguale per tutte le persone (che hanno la testa), ma di distinguerle fra loro in base ad un confronto con alcune immagini di test da fornire per il database.</p> <p>Per procedere con l'installazione, dal solito terminale con l'ambiente virtuale attivo, digitate:</p> <pre><code>$ pip install setuptools\n$ pip install dlib\n$ pip install face-recognition\n$ pip install imutils\n</code></pre> <p>Poi posso procedere cos\u00ec...</p> Fai le foto alle persone da riconoscere<pre><code>import cv2\n\nname = 'silvia' #replace with your name\n\ncam = cv2.VideoCapture(0)\n\ncv2.namedWindow(\"press space to take a photo\", cv2.WINDOW_NORMAL)\ncv2.resizeWindow(\"press space to take a photo\", 500, 300)\n\nimg_counter = 0\n\nwhile True:\n    ret, frame = cam.read()\n    if not ret:\n        print(\"failed to grab frame\")\n        break\n    cv2.imshow(\"press space to take a photo\", frame)\n\n    k = cv2.waitKey(1)\n    if k%256 == 27:\n        # ESC pressed\n        print(\"Escape hit, closing...\")\n        break\n    elif k%256 == 32:\n        # SPACE pressed\n        img_name = \"dataset/\"+ name +\"/image_{}.jpg\".format(img_counter)\n        cv2.imwrite(img_name, frame)\n        print(\"{} written!\".format(img_name))\n        img_counter += 1\n\ncam.release()\ncv2.destroyAllWindows()\n</code></pre> <p>Allena il modello per il riconoscimento facciale...</p> Train Model<pre><code># import the necessary packages\nfrom imutils import paths\nimport face_recognition\n#import argparse\nimport pickle\nimport cv2\nimport os\n\n# our images are located in the dataset folder\nprint(\"[INFO] start processing faces...\")\nimagePaths = list(paths.list_images(\"dataset\"))\n\n# initialize the list of known encodings and known names\nknownEncodings = []\nknownNames = []\n\n# loop over the image paths\nfor (i, imagePath) in enumerate(imagePaths):\n    # extract the person name from the image path\n    print(\"[INFO] processing image {}/{}\".format(i + 1,\n        len(imagePaths)))\n    name = imagePath.split(os.path.sep)[-2]\n\n    # load the input image and convert it from RGB (OpenCV ordering)\n    # to dlib ordering (RGB)\n    image = cv2.imread(imagePath)\n    rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n\n    # detect the (x, y)-coordinates of the bounding boxes\n    # corresponding to each face in the input image\n    boxes = face_recognition.face_locations(rgb,\n        model=\"hog\")\n\n    # compute the facial embedding for the face\n    encodings = face_recognition.face_encodings(rgb, boxes)\n\n    # loop over the encodings\n    for encoding in encodings:\n        # add each encoding + name to our set of known names and\n        # encodings\n        knownEncodings.append(encoding)\n        knownNames.append(name)\n\n# dump the facial encodings + names to disk\nprint(\"[INFO] serializing encodings...\")\ndata = {\"encodings\": knownEncodings, \"names\": knownNames}\nf = open(\"encodings.pickle\", \"wb\")\nf.write(pickle.dumps(data))\nf.close()\n</code></pre> <p>Infine, vai con il riconoscimento facciale...</p> Face Recognition<pre><code># import the necessary packages\nfrom imutils.video import VideoStream\nfrom imutils.video import FPS\nimport face_recognition\nimport imutils\nimport pickle\nimport time\nimport cv2\n\n#Initialize 'currentname' to trigger only when a new person is identified.\ncurrentname = \"unknown\"\n#Determine faces from encodings.pickle file model created from train_model.py\nencodingsP = \"encodings.pickle\"\n\n# load the known faces and embeddings along with OpenCV's Haar\n# cascade for face detection\nprint(\"[INFO] loading encodings + face detector...\")\ndata = pickle.loads(open(encodingsP, \"rb\").read())\n\n# initialize the video stream and allow the camera sensor to warm up\n# Set the ser to the followng\n# src = 0 : for the build in single web cam, could be your laptop webcam\n# src = 2 : I had to set it to 2 inorder to use the USB webcam attached to my laptop\nvs = VideoStream(src=0,framerate=10).start()\n#vs = VideoStream(usePiCamera=True).start()\ntime.sleep(2.0)\n\n# start the FPS counter\nfps = FPS().start()\n\n# loop over frames from the video file stream\nwhile True:\n    # grab the frame from the threaded video stream and resize it\n    # to 500px (to speedup processing)\n    frame = vs.read()\n    frame = imutils.resize(frame, width=500)\n    # Detect the fce boxes\n    boxes = face_recognition.face_locations(frame)\n    # compute the facial embeddings for each face bounding box\n    encodings = face_recognition.face_encodings(frame, boxes)\n    names = []\n\n    # loop over the facial embeddings\n    for encoding in encodings:\n        # attempt to match each face in the input image to our known\n        # encodings\n        matches = face_recognition.compare_faces(data[\"encodings\"],\n            encoding)\n        name = \"Unknown\" #if face is not recognized, then print Unknown\n\n        # check to see if we have found a match\n        if True in matches:\n            # find the indexes of all matched faces then initialize a\n            # dictionary to count the total number of times each face\n            # was matched\n            matchedIdxs = [i for (i, b) in enumerate(matches) if b]\n            counts = {}\n\n            # loop over the matched indexes and maintain a count for\n            # each recognized face face\n            for i in matchedIdxs:\n                name = data[\"names\"][i]\n                counts[name] = counts.get(name, 0) + 1\n\n            # determine the recognized face with the largest number\n            # of votes (note: in the event of an unlikely tie Python\n            # will select first entry in the dictionary)\n            name = max(counts, key=counts.get)\n\n            #If someone in your dataset is identified, print their name on the screen\n            if currentname != name:\n                currentname = name\n                print(currentname)\n\n        # update the list of names\n        names.append(name)\n\n    # loop over the recognized faces\n    for ((top, right, bottom, left), name) in zip(boxes, names):\n        # draw the predicted face name on the image - color is in BGR\n        cv2.rectangle(frame, (left, top), (right, bottom),\n            (0, 255, 225), 2)\n        y = top - 15 if top - 15 &gt; 15 else top + 15\n        cv2.putText(frame, name, (left, y), cv2.FONT_HERSHEY_SIMPLEX,\n            .8, (0, 255, 255), 2)\n\n    # display the image to our screen\n    cv2.imshow(\"Facial Recognition is Running\", frame)\n    key = cv2.waitKey(1) &amp; 0xFF\n\n    # quit when 'q' key is pressed\n    if key == ord(\"q\"):\n        break\n\n    # update the FPS counter\n    fps.update()\n\n# stop the timer and display FPS information\nfps.stop()\nprint(\"[INFO] elasped time: {:.2f}\".format(fps.elapsed()))\nprint(\"[INFO] approx. FPS: {:.2f}\".format(fps.fps()))\n\n# do a bit of cleanup\ncv2.destroyAllWindows()\nvs.stop()\n</code></pre> <p>Attenzione!!!</p> <p>Ha funzionato tutto SOLO installando tutto su Python 3.8 con uv...</p>"},{"location":"rpi/00_intro/","title":"Raspberry PI","text":"<p>Raspberry Pi (da ora in poi mi riferir\u00f2 ad esso chiamandolo semplicemente Raspberry, oppure con la sigla RPI) \u00e8 un microcomputer delle dimensioni di una carta di credito. Progettato dalla Raspberry PI Foundation, la sua prima release \u00e8 avvenuta nel 2012 e rappresenta uno dei migliori esempi di applicazione dei modelli di business promossi da Hardware libero e Software libero insieme.</p> <p>Siti di riferimento</p> <p>Il sito della <code>Raspberry Pi Foundation</code> \u00e8 https://www.raspberrypi.org/. Qui potete trovare tutte le informazioni sociali a riguardo: documentazione, progetti, tutorial, iniziative, etc...</p> <p>Il sito commerciale \u00e8 invece https://www.raspberrypi.com/. Qui troverete informazioni sulla produzione e l'utilizzo dei Raspberry nel mondo, potrete acquistarne uno o scaricare il software per farlo funzionare.</p> <p>Viene ampiamente utilizzato per l'implementazione di migliaia di progetti che includono workstation desktop a basso costo, media center, smart home, robot, server tascabili, sensoristica, prototyping, ecc. E per tutto quello che viene definito <code>IoT</code>, Internet of Things.</p> <p>Il sistema operativo ufficiale si chiama <code>Raspberry Pi OS</code>, \u00e8 basato su Linux e trovate sul sito commerciale ogni informazione su download, installazione, primo utilizzo. In alternativa, \u00e8 possibile eseguire su id esso una versione specifica di Windows, chiamata Windows for IoT.</p> <p>Contiene diverse interfacce hardware di utilizzo comune:</p> <ul> <li>USB.</li> <li>ethernet (rete cablata).</li> <li>HDMI.</li> <li>fotocamera.</li> <li>audio (jack da 3.5mm, quello delle cuffie).</li> <li>display</li> <li>GPIO (un'interfaccia generica a cui collegare qualsiasi sensore).</li> <li>Wifi e Bluetooth onboard</li> </ul> <p></p> <p>Il mondo Finora, Raspberry Pi si \u00e8 sviluppato fino alla quarta generazione. Le modifiche nelle versioni sono accompagnate da aumenti e aggiornamenti dell\\'hardware. Fortunatamente dalla versione 2 in avanti le interfacce e la GPIO si sono uniformati, in modo che qualsiasi progetto possa essere eseguito pi\u00f9 o meno allo stesso modo in qualunque delle ultime versioni.</p> <p>A scuola abbiamo una serie di <code>RPI versione 3, modello B+</code>, modello a cui si riferisce la figura precedente. La nostra trattazione da qui in avanti si rivolger\u00e0 esplicitamente a questo tipo di RPI. Sappiate comunque che con modifiche minime (e spesso nessuna) quello che vediamo pu\u00f2 essere replicato in molte altre versioni di RPI.</p> <p>Iniziamo!!</p> <p> </p>"},{"location":"rpi/01_installation/","title":"Installazione","text":"<p>Per installare un qualsiasi sistema operativo su RPI abbiamo bisogno delle seguenti cose:</p> <ul> <li>un RPI :)</li> <li>un sistema operativo :))</li> <li>Una card MicroSD (far\u00e0 da Hard Disk al raspberry)</li> <li>un adattatore USB oppure SD per scrivere sulla MicroSD (dipende se     il vostro PC ha un lettore SD o solo porte USB)</li> <li>un cavo MicroUSB per alimentare il raspberry</li> </ul> <p>A proposito di alimentazione del raspberry, ecco una tabella riassuntiva di quanto questi piccoli dispositivi necessitano a livello energetico</p> Prodotto Corrente Assorbimento Massimo Consumo tipico RPI 3 Model B 2.5A 1.2A 400mA RPI 3 Model B+ 2.5A 1.2A 500mA RPI 4 Model B 3.0A 1.2A 600mA RPI Zero W 1.2A (limitato) 150mA <p>Se vogliamo fare proprio i precisoni, fra il materiale necessario bisogna elencare anche:</p> <ul> <li>Un monitor con ingresso HDMI (oppure VGA con adattatore HDMI)</li> <li>un mouse e una tastiera con uscite USB</li> <li>Un cavo ethernet per il collegamento alla rete (senza WIFI)</li> </ul> <p>La procedura che segue mostrer\u00e0 come installare <code>Raspberry Pi OS</code>, il sistema operativo basato su Debian Linux e ottimizzato per raspberry.</p> <p>A partire dal link: https://www.raspberrypi.com/software/, tramite il Raspberry Pi Imager saranno proposte varie opzioni di download, tra cui:</p> <ol> <li>with desktop and recommended software</li> <li>with desktop</li> <li>lite</li> </ol> <p>Io consiglio sempre di scaricare e installare la seconda (quella con il solo desktop), perch\u00e9 avere l'interfaccia grafica \u00e8 un bel vantaggio per molti (la versione lite ha solo interfaccia testuale) ma il software raccomandato consiste in parecchi GB di software potenzialmente inutile ai nostri scopi.</p> <p>Selezionata la scheda (Micro)SD di riferimento, la versione del sistema operativo richiesta, la versione del Raspberry che dovr\u00e0 eseguirlo, si fa partire il processo e ... si aspetta.</p> <p>Fatta la copia del sistema operativo sulla scheda MicroSD, inseritela nel raspberry, collegate tutto ci\u00f2 che serve (mouse, tastiera, monitor, rete) e per ultimo l'alimentazione.</p> <p>il raspberry non ha un tasto di accensione!</p> <p>Il collegamento alla corrente deve essere quindi l'ultima cosa da fare quando si prepara un Raspberry per l'accensione.</p> <p></p> <p>| Ecco fatto! | Buon Raspberry a tutti!</p> <p>Suggerimento</p> <p>Il sistema operativo Raspberry propone di default il seguente utente.</p> <p>USER: pi PASS: raspberry</p> <p>Nella versione desktop comunque, l'utente ha l'accesso automatico abilitato (senza digitare la password), quindi nella realt\u00e0 all'inizio questa informazione non serve. Per qualsiasi operazione amministrativa per\u00f2, sar\u00e0 richiesta l'autenticazione!</p>"},{"location":"rpi/02_base/","title":"Operazioni di base","text":"<p>Ripartiamo dal Raspberry come lo abbiamo lasciato un attimo fa: acceso, pronto (caricamento iniziale finito), con interfaccia grafica</p> <p></p> <p>Ricordo inoltre le credenziali dell'account di default.</p> <p>USER: pi PASS: raspberry</p> <p>Il tool che ci viene presentato davanti serve per la configurazione iniziale. Mi raccomando di non cambiare la password dell'utente pi a meno che non siate assolutamente sicuri di ricordarvela. In caso siate senza interfaccia grafica, oppure vogliate procedere con la buona vecchia riga di comando, chiudete quella finestra e leggetevi il prossimo capitolo.</p>"},{"location":"rpi/02_base/#configurazione-raspberry","title":"Configurazione Raspberry","text":"<p>Il sistema operativo <code>Raspberry Pi OS</code> fornisce un tool a linea di testo da cui accedere a tutte le configurazioni di base del Raspberry. Per accedere ad esso si dovr\u00e0 utilizzare il comando sudo.</p> <pre><code>$ sudo raspi-config\n</code></pre> <p>A quel punto si avr\u00e0 accesso ad una interfaccia grafica-testuale con cui completare la configurazione:</p> <p></p> <p>Le opzioni sono in ordine e si pu\u00f2 procedere tramite esse a configurare il Raspberry. Alcune opzioni sono chiarissime e non necessitano di spiegazioni; ad esempio quella di cambiare password :)</p> <p>Mi dedico a quelle che di solito servono:</p> Network Options <p>Le opzioni che trovate qui servono per impostare la rete. Sono cose che potete fare tranquillamente anche tramite l'interfaccia grafica, se la utilizzate.</p> <p>L'opzione importante da settare all'inizio riguarda per\u00f2 l'hostname, il nome del vostro Raspberry! Tramite quello sar\u00e0 pi\u00f9 facile identificarlo nella rete! Per applicare questa impostazione serve di riavviare il Raspberry. Potete farlo anche alla fine di tutta la configurazione ;)</p> Localisation Options <p>Queste opzioni servono per la localizzazione: tastiera italiana, lingua dei programmi, data, ora e loro formati, WiFi country code, etc... Sono molto importanti da impostare all'inizio in modo da non aver pi\u00f9 problemi successivamente. Passate ognuna delle impostazioni alla ricerca delle opzioni italiane; per quanto riguarda il locale scegliete l'opzione it_IT.UTF-8.</p> Interfacing Options <p>In questo men\u00f9 ci sono le opzioni per attivare o disattivare alcune periferiche o alcuni strumenti software per l'interazione con il Raspberry. Tra queste opzioni di interfaccia troviamo la camera, i bus I2C, 1-wire e SPI, la seriale, la remote GPIO, i software SSH e VNC. Attivate o disattivate ci\u00f2 che vi serve (se non sapete che vi serve... disattivatelo). Per applicare le opzioni serve il riavvio.</p> Advanced Options <p>Qui ci sono impostazioni abbastanza complicate, studiare... per credere!</p> <p>Terminate le impostazioni \u00e8 importantissimo procedere ad un riavvio per essere sicuro di aver applicato tutte le modifiche necessarie!</p>"},{"location":"rpi/02_base/#prime-operazioni","title":"Prime operazioni","text":"<p>Riavviato il sistema operativo, diamo un occhio pi\u00f9 da vicino al desktop del Raspberry</p> <p></p> <p>Poich\u00e9 considero siate utenti di fascia medio-alta davanti ad un Sistema Operativo, immagino non abbiate problemi ad individuare le applicazioni pi\u00f9 comuni che di certo utilizzeremo su Raspberry.</p> <p>Le elenco:</p> <ul> <li>Browser (Chromium, la versione opensource di Google Chrome)</li> <li>File manager (PCManFM, un software per navigare tra i file del Raspberry)</li> <li>Terminale (Terminal, per accedere alla riga di comando)</li> <li>Text Editor grafico (Mousepad, un programma tipo il Blocco Note di Windows)</li> <li>Text Editor testuale (nel terminale: nano)</li> <li>Editor Python (IDLE, oppure Thonny... Facile!)</li> </ul> <p>Considero inoltre che siate in grado di muovermi nel men\u00f9 principale alla ricerca di una applicazione e sappiate interagire con la system tray per operazioni tipo controllare l'ora, abilitare/disabilitare bluetooth o wifi, montare e smontare una penna USB, etc...</p> <p>Se volete prendere confidenza con queste operazioni, questo \u00e8 il momento di farlo, prima di andare avanti e inesorabilmente iniziare a fingere di aver capito...</p> <p>Suggerimento</p> <p>Fra le tante cose nuove su cui documentarsi, vale secondo me la pena di spendere 5 minuti e curiosare su Internet a proposito della organizzazione del file system su linux.</p> <p>Provate a cercare quella frase in rete e a leggere qualcosa a proposito.</p> <p>5 minuti, dai...</p>"},{"location":"rpi/02_base/#il-terminale-linux","title":"Il terminale Linux","text":"<p>Adesso vogliamo dedicare un p\u00f2 di tempo a prendere confidenza con il terminale Linux. Utilizzare l'interfaccia testuale pu\u00f2 essere molto vantaggioso in diversi casi:</p> <ul> <li> <p>Tutti i sistemi Linux hanno la stessa interfaccia testuale, ma le     interfacce grafiche sono potenzialmente tutte diverse</p> </li> <li> <p>La connessione remota ad un dispositivo in modalit\u00e0 testuale \u00e8     veloce, sicura e facile da stabilire</p> </li> <li> <p>L'interfaccia testuale \u00e8 molto potente. Pensate all'interfaccia     grafica del vostro Sistema Operativo preferito:</p> <ul> <li>Come si fa a controllare l'IP della macchina?</li> <li>Come si fa a cercare un file all'interno di tutto il     computer?</li> <li>Come si fa a disintallare un programma? Arrestare un servizio?</li> </ul> </li> </ul> <p>Tutte queste operazioni costano un unico comando, una riga di codice con l'interfaccia testuale. E richiedono un secondo o poco pi\u00f9 per l'esecuzione.</p> <p>Adesso che ho attirato la vostra attenzione sull'utilizzo della linea di testo, vediamo alcuni semplici comandi organizzati per utilizzo:</p> <p>Muoversi fra i file</p> Comando Descrizione ls Elenca i file nella directory corrente (list) cd Cambia Directory. pwd Directory corrente <p>Manipolazione del testo</p> Comando Descrizione cat Concatena i file e ne manda il contenuto nello standard output less Visualizza il contenuto di un file nano Editor testuale <p>Gestione di file e directory</p> Comando Descrizione mkdir Crea una directory, una cartella touch Crea un file cp Copia un file o una directory mv Sposta un file o una directory rm Rimuove un file o una directory <p>Sistema</p> Comando Descrizione shutdown Inizia la procedura di spegnimento reboot Riavvia il sistema <p>Utilities</p> Comando Descrizione history Elenca la cronologia dei comandi digitati man Apre il manuale richiesto <p>Permessi di esecuzione</p> <p>Il comando <code>sudo</code> permette di eseguire qualsiasi comando con privilegi amministrativi.</p> <p>Basta precedere <code>sudo</code> a qualsiasi comando per fare come se fosse l'amministratore del sistema ad eseguirlo.</p> <p></p>"},{"location":"rpi/02_base/#gestione-software","title":"Gestione software","text":"<p>L' Advanced Packaging Tool (conosciuto con l'acronimo <code>apt</code>) \u00e8 il gestore standard di pacchetti software della distribuzione Debian e di tutte le sue derivate. In particolare vale la pena di ricordare Ubuntu e Raspberry come derivate di punta.</p> <p>Questo sistema di gestione dei pacchetti \u00e8 in grado di cercare, scaricare, installare qualsiasi software disponibile nei repository indicati nei file di configurazione per renderli disponibile all'istante!</p> <p>Attenzione!</p> <p>Poich\u00e9 il comando <code>apt</code> si occupa di operazioni amministrative, deve essere sempre preceduto dal comando <code>sudo</code>.</p> <p>Vediamo via via le opzioni di <code>apt</code> pi\u00f9 importanti:</p> <pre><code>$ sudo apt update\n</code></pre> <p>Aggiorna l'elenco del software presente nel repository. In questo modo APT sapr\u00e0 qual \u00e8 l'ultima versione del software disponibile online.</p> <pre><code>$ sudo apt upgrade\n</code></pre> <p>Sincronizza il software di sistema con quello presente nel repository. Praticamente permette di aggiornare tutto il software all'ultima versione disponibile.</p> <pre><code>$ sudo apt search package\n</code></pre> <p>Cerca il termine \"package\" fra i pacchetti software disponibili nel repository. Funziona anche senza sudo.</p> <pre><code>$ sudo apt install package\n</code></pre> <p>Scarica \"package\" e lo installa nel sistema, rendendolo disponibile all'utente.</p> <pre><code>$ sudo apt remove package\n</code></pre> <p>Rimuove \"package\" dal sistema.</p>"},{"location":"rpi/03_remote/","title":"Collegamento da remoto","text":"<p>Una volta che hai sistemato il raspberry e hai effettuato l'installazione del sistema operativo e dato un'occhiata al tutto, potrebbe tornarti utile non scollegare ogni volta mouse, tastiera, monitor e tutto il laboratorio, ma semplicemente collegare il raspberry alla rete e all'alimentazione e collegartici da remoto!</p> <p>I metodi pi\u00f9 utilizzati per la connessione remota al raspberry sono sostanzialmente 3: elencher\u00f2 il nome comune della tecnologia, il software (server) che va installato su raspberry per renderlo disponibile e il client da utilizzare su Windows 10 per la connessione remota, visto che a scuola abbiamo PC con Windows 10. Se avete dispositivi con sistemi operativi Mac o Linux, documentatevi su Internet sui client per la corrispondente tecnologia.</p> Protocollo Tipologia Server (su RPI) Client (su Win10) RDP Grafica Xrdp Remote Desktop VNC Grafica vnc VNC Viewer SSH Testuale sshd Putty <p>Nota bene</p> <p>Qualsiasi metodo sceglierai, ricordati che avrai bisogno di conoscere il nome e/o l'indirizzo IP del tuo raspberry!</p> <p>Cerca di capire prima come sia possibile ottenere (e magari modificare) queste informazioni!</p>"},{"location":"rpi/03_remote/#rdp","title":"RDP","text":"<p>Remote Desktop Protocol \u00e8 un protocollo di rete proprietario sviluppato da Microsoft, che permette la connessione remota da un computer a un altro in maniera grafica. Il protocollo di default utilizza la porta TCP e UDP 3389.</p> <p>I client RDP esistono per la maggior parte delle versioni di Microsoft Windows, Linux, Unix, macOS, Android, iOS. I server RDP ufficiali esistono per i sistemi operativi Windows nonostante ne esistano anche per i sistemi Unix-Like.</p> <p>Su RPi</p> <p>Installa il servizio xrdp:</p> <pre><code>$ sudo apt install xrdp\n</code></pre> <p>Fatto questo, riavvia.</p> <p>Su Windows</p> <p>Non devi fare nulla! Ti basta cercare il software Connessione a Desktop Remoto</p>"},{"location":"rpi/03_remote/#vnc","title":"VNC","text":"<p>Virtual Network Computing \u00e8 un protocollo per applicazioni software di controllo remoto, utilizzato per amministrare il proprio computer a distanza. Pu\u00f2 essere utilizzato anche per controllare in remoto server che non posseggono n\u00e9 monitor n\u00e9 tastiera.</p> <p>Il protocollo di comunicazione usato a livello di trasporto \u00e8 il TCP sulla porta di default 5900, oppure tramite interfaccia HTTP sulla porta 5800/tcp.</p> <p>Su RPI</p> <p>Il server VNC \u00e8 disponibile di default su Raspbian, ma va abilitato tramite raspi-config: Interfacing Options --&gt; VNC --&gt; Enable</p> <p>Fatto questo, riavvia.</p> <p>Su Windows</p> <p>Un client VNC gratuito \u00e8 il VNC Viewer di RealVNC: https://www.realvnc.com/en/connect/download/viewer/windows/</p> <p>Scaricalo, installalo su Windows e provalo.</p>"},{"location":"rpi/03_remote/#ssh","title":"SSH","text":"<p>Secure Shell \u00e8 un protocollo che permette di stabilire una sessione remota cifrata tramite interfaccia a riga di comando con un altro host di una rete informatica. \u00c8 il protocollo che ha sostituito l'analogo, ma insicuro, Telnet, perch\u00e9 basato su una comunicazione non cifrata.</p> <p>A livello server utilizza la porta 22, sia tramite TCP che UDP.</p> <p>Su RPI</p> <p>Il server SSH \u00e8 disponibile di default su Raspbian, ma va abilitato tramite raspi-config: Interfacing Options --&gt; SSH --&gt; Enable</p> <p>Fatto questo, riavvia.</p> <p>Su Windows</p> <p>Ti basta scaricare Putty e usarlo senza neanche installarlo!</p> <p>Il sito ufficiale \u00e8: https://www.putty.org/</p>"},{"location":"rpi/04_multimedia/","title":"Multimedia","text":"<p>Quello che si vuole intendere in questa sezione come Multimedia \u00e8 la possibilit\u00e0 di utilizzare con il nostro Raspberry alcune periferiche che poi torneranno utili nell'utilizzo dell'Intelligenza Artificiale.</p> <p>Queste periferiche nello specifico sono:</p> <ul> <li>Una Webcam USB (utile per il riconoscimento facciale)</li> <li>Un microfono (per parlare, nella nostra dotazione \u00e8 integrato nella     webcam)</li> <li>le casse audio (per ascoltare musica e...la AI che parla!!!)</li> </ul>"},{"location":"rpi/04_multimedia/#webcam","title":"Webcam","text":"<p>Attenzione</p> <p>Per poter utilizzare la webcam (ovvero accedere al file della periferica che la rappresenta) bisogna far parte del gruppo video. L'utente pi \u00e8 automaticamente parte di questo gruppo. Se vuoi verificare digita:</p> <pre><code>$ groups\n</code></pre> <p>Verranno elencati i gruppi di cui l'utente corrente fa parte. Se per qualche motivo video non fosse fra questi, bisogna aggiungere il proprio utente al gruppo con il comando:</p> <pre><code>$ sudo usermod -a -G video NOMEUTENTE\n</code></pre> <p>E rifare il login</p> <p>Per poter utilizzare la webcam, basta collegarla al Raspberry e installare il software necessario al suo utilizzo:</p> <pre><code>$ sudo apt install fswebcam\n</code></pre> <p>Questione di 1 minuto...</p> <p>Per fare una prima prova e farsi una foto con la webcam, basta digitare:</p> <pre><code>$ fswebcam prova.jpg\n</code></pre> <p>Sorridete, poi aprite il file manager, andate a guardare la foto e controllate il risultato :)</p> <p></p> <p>Per modificare la risoluzione, si pu\u00f2 agire con il parametro -r. Basta non esagerare. Ad esempio:</p> <pre><code>$ fswebcam -r 800x600 prova2.jpg\n</code></pre> <p>Se non vi piace la barra sotto (il banner), basta eliminarlo con l'opzione --no-banner</p> <pre><code>$ fswebcam -r 800x600 --no-banner prova3.jpg\n</code></pre> <p>Il risultato:</p> <p></p> <p>Pi\u00f9 o meno tutto qui!</p>"},{"location":"rpi/04_multimedia/#casse-audio","title":"Casse audio","text":"<p>Queste sono davvero semplici da provare! Collegate le casse al Raspberry (jack e USB per l'alimentazione) e provate a sentire un video di Youtube! Se non funziona, forse il problema \u00e8 che la periferica collegata al jack non \u00e8 stata riconosciuta. Per assicurarci della cosa, proviamo con:</p> <pre><code>$ sudo raspi-config\n\nAdvanced Options ---&gt; Audio ---&gt; Jack (o pipewire??)\n</code></pre> <p>E questo \u00e8 tutto!</p>"},{"location":"rpi/04_multimedia/#microfono-integrato","title":"Microfono integrato","text":"<p>Una volta positivamente testate le casse, si potr\u00e0 provare anche con il microfono: baster\u00e0 registrare qualche secondo di conversazione e poi provare a riascoltarla!</p> <p>Per fare ci\u00f2, procediamo con le utility installate tramite pulseaudio. Per registrare:</p> <pre><code>$ arecord prova.wav\n</code></pre> <p>Dite una frase tipo \"che bello questo corso!!!\", aspettate un paio di secondi e poi premete la combinazione di tasti CTRL + C per interrompere la registrazione.</p> <p>Per riascoltare le nostre soavi parole, digitate un bel:</p> <pre><code>$ aplay prova.wav\n</code></pre> <p>E anche questa \u00e8 fatta!!!</p>"}]}